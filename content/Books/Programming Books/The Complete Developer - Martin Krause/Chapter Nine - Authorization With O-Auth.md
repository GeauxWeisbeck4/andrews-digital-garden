---
id: 01J9QDC4G8AEAP7HCJ275A0NX8
modified: 2024-10-08T21:13:54-04:00
title: Chapter Nine - Authorization With O-Auth
description: Learning how to use Authorization
tags:
  - programming
  - web-development
  - full-stack
  - authorization
  - o-auth
  - books
---
Certain apps store data about users as part of a login workflow. There are many ways to implement this authentication and authorization, but one of the easiest is to use OAuth2 to piggyback on the existing accounts of well-known companies. _OAuth2_, or simply _OAuth_, is an open standard for access delegation, and you’ve probably encountered it if you’ve ever used an app’s “log in with Facebook, GitHub, or Google Account” feature.

The OAuth protocol essentially allows our web application to access another application’s login data without requiring the third party to share a user’s credentials with us. To do so, the user grants our application access rights to their third-party account through the creation of an access token. OAuth is the accepted standard for authorization-based access delegation, and Amazon, Google, Facebook, Microsoft, and GitHub all support OAuth workflows.

This chapter will introduce you to the OAuth workflow and then explore the structure of the bearer tokens used for its access delegation, laying the foundation for implementing OAuth2 into your Food Finder application in [Part II](https://learning.oreilly.com/library/view/the-complete-developer/9781098168810/xhtml/part2.xhtml). In [Exercise 9](https://learning.oreilly.com/library/view/the-complete-developer/9781098168810/xhtml/chapter9.xhtml#Exe9) on page 168, we won’t update our sample Next.js application with an OAuth flow but instead manually walk through the OAuth authorization process.

### How OAuth Works

Before we explore OAuth, you need to understand the differences between authentication and authorization. In short, we use authentication to verify the identity of a user, whereas authorization specifies the permissions that the authenticated user possesses and enforces those permissions. OAuth allows for that process to be delegated to a third party with which the user already has an account, which simplifies the login process for the user.

#### Authentication vs. Authorization

Every time an app receives a login request, it checks the user’s credentials before allowing access, a process called _authentication_. Usually, those credentials consist of a username and a password, but they could also be hardware tokens or involve biometric factors such as fingerprints or facial recognition. The application then verifies that the credentials match the ones stored in the database.

The simplest form of authentication is _single-factor authentication_, which requires only one factor, usually a password. Unfortunately, it is also the least secure method of implementing authentication. A more robust and recommended form is _multifactor authentication_, in which a user must supply at least two factors. These might be something the user _knows_, such as a password, as well as something the user _has_, such as a physical token, or something the user _is_, such as the owner of a fingerprint. You probably use multifactor authentication when you log in to PayPal or Google, both of which require you to supply your password and an additional one-time password (OTP).

The OTP is a code that is created based on a secret shared between you and the application when you register your account. Both actors regenerate the pair in short intervals. Yours may be generated by an authenticator app, like Google Authenticator, or received in a text message. The application at which you have the account (for example, PayPal or Google) generates its own OTP code and keeps it on the server. As soon as you send yours, the server verifies that the codes cryptographically match.

We perform authorization after we’ve authenticated a user. Broadly speaking, this involves looking at the user’s data and deciding whether they have the access rights needed to access a resource. A typical full-stack application can either handle this user data or enable users to log in without providing user data. There are benefits to the latter approach, as handling and storing user data can be inconvenient. It also comes with additional responsibilities, such as the need to adhere to stricter privacy and data retention laws, and requires your users to create another account.

Suppose you provide users with the option to log in with an existing account through an authorization provider. In that case, you’ve removed an entry barrier. Also, you don’t need to worry about handling their data. If you need user data—for example, to bill your customers—you can use an OAuth workflow and save the data you receive from the provider, such as the user’s payment details, in your own database if necessary.

#### The Role of OAuth

Every time a web application enables you to log in through a third-party provider such as Facebook, GitHub, or Google, it uses the OAuth authorization code flow behind the scenes. OAuth isn’t authentication; rather, it’s a way of authorizing the web application you use to perform actions or to access resources on your behalf. Common actions include posting to your Facebook feed and accessing data such as your name, profile picture, or email address. Consequently, each time you use an OAuth-based login function, the application asks for particular permissions and can use only those you grant to it.

To understand OAuth, you must understand its terminology. Each OAuth flow uses a set of RESTful APIs to authorize the _client_ (an application) to get resources (such as the user’s profile information) from a _resource provider_ (such as Facebook, GitHub, or Google) that has the protected resources the client wants to access. In addition, we call the server that provides the OAuth API endpoints the _authorization server_, and the party that owns the access rights (and, hence, has the ability to grant an application access to a resource) the _resource owner_. In most scenarios, the resource owner is the application’s end user.

To get the resource owner’s authorization, the client application sends its client credentials, the ID, the secret, and the user credentials to the authorization server, which usually is part of the same system as the resource provider. The authorization server authenticates the resource owner and handles the OAuth flow that results in granting them an _access token_, which allows the user to access the protected resources on the resource provider. Both the authorization server and the resource provider are two sets of APIs on the same system.

The _client ID_ is a public identifier for the client app; you can make it public and store it in the code. Unlike the client ID, the _client secret_ should be kept private; it is the app-specific password, and you should never store it in your code. Instead, handle it using Next.js’s environment files or your server’s environment variables.

#### Grant Types

There are several variants of the OAuth flow. Each of these _grant types_ covers a specific use case, but all result in the generation of an access token. OAuth specifies four grant types: the client credentials flow, the implicit flow, the authorization code flow, and the resource owner password credentials flow.

The _client credentials flow_ covers machine-to-machine communication; we use it when no actual end user authorization is necessary, as in the case of automated tasks that connect to an API. Here, the task itself is both the client and the resource owner. It knows the resource owner’s credentials, the client ID, and the client secret and passes these to the authorization server to receive an access token.

The most common grant type for full-stack web development is the _authorization code flow_. In this scenario, our web application is a client, and it makes two calls to two separate API endpoints. The first is to receive an authorization grant code, and the second is to exchange this authorization grant for an access token. “The Authorization Code Flow” on page 161 provides a deep dive into this process.

The last two grant types shouldn’t be used. The _implicit flow_ is similar to the authorization code flow, but instead of making separate requests to receive the authorization grant and access token, the client receives the access token directly. This flow skips the authorization step, doesn’t include client authentication, and is deprecated. The _resource owner password credentials flow_ should be avoided because it involves the end user passing their user credentials to the client and then the client sending these credentials to the OAuth server to exchange them for the access token. While this sounds straightforward, sending actual user credentials to the remote authorization server is an immense security risk.

#### Bearer Tokens

After the client application initiates an OAuth flow, it receives a shared access token, most commonly a _bearer token_ that is easy to implement. This access token replaces the user’s credentials; hence, anyone who has the token can access the data. To prevent security gaps caused by stolen tokens, a bearer token usually has a defined shelf life. Upon expiration, the token can be refreshed only with a valid _refresh token_. These are long-lived tokens that we use to generate new bearer tokens.

Refreshing the token can be done implicitly or explicitly, and there are multiple strategies for preventing stolen refresh tokens from compromising the OAuth access. For example, the OAuth provider can require a unique ID or the client secret to issue a new token. The provider usually rotates the refresh token each time a new bearer token is issued and accepts each refresh token only once. From our perspective as OAuth clients, the details of the refresh token are unimportant, as the OAuth provider handles this token.

The bearer token that contains the user session and authentication data is a _JSON Web Token (JWT)_. JWT is an open standard for securely transmitting data in a JSON object. Because JSON is fairly compact, JWTs can be sent as URL parameters, as part of the POST data, or even inside an HTTP header, all without impacting the application’s performance.

JWT tokens can be signed as well as encrypted, saving the application from needing to make an additional request to verify it or retrieve extra data. _Encrypted tokens_ hide the contained data from other parties. These aren’t very common in OAuth due to their additional overhead, so we can ignore them for now. _Signed tokens_ guarantee the integrity of the contained data, because any modification to the token would change its signature. Thus, the application can trust the information stored in it.

The most common cryptographic algorithm for signing JWTs is _hash-based message authentication code (HMAC)_ with the SHA-256 hash algorithm. An HMAC is a type of message authentication code (MAC). A MAC’s main feature is that it enables you to verify the authenticity of a message by calculating a checksum from the message. The checksum uses a mathematical function to produce a unique, reproducible value or data string based on the initial message. If the message changes, the checksum changes as well. This way, we can quickly verify the integrity of the data. For the JWT token, we use two checks: the authenticity check confirms that the actual sender sent the message, whereas the data integrity checks verify that the message’s content did not change.

Unlike other types of MACs, HMAC uses a cryptographic hash function and a secret key. You can freely choose the cryptographic hash function, but the strength of your HMAC implementation depends on the cryptographic strength of the selected function. JWTs commonly use the SHA-256 hash function, a fast and collision-resistant cryptographic function from the SHA-2 collection also used for authenticating Debian software packages and Bitcoin transactions. In cryptography, _collisions_ occur when two different inputs result in the same output. The higher the possibility of a collision, the less we can trust the checksum of the hash function. If a collision is likely, our message could be replaced with a different one, but the hash function could indicate that it hasn’t changed. Therefore, we want collision-resistant cryptographic functions.

### The Authorization Code Flow

To understand how an OAuth interaction takes place using the authorization code flow mentioned earlier, let’s return to our fictional weather service. Imagine that you want to grant weather stations the ability to write data to the application by using the API, but a station should be able to modify only its own ZIP code. You also want the application to display the weather stations’ locations and additional details about them. Additionally, you prefer not to deal with the maintenance of user accounts or to manually set up permissions for each station, so using OAuth is your best bet.

Let’s assume that each weather station already has a social media account for publishing weather updates. These accounts include typical user information and the stations’ ZIP codes. We could easily use the social media provider as an OAuth authorization provider to access this data. The stations would log in to the weather app using the social media provider, and the app would request access to the weather station’s user profile. We could then check the ZIP code stored in the OAuth session against the one in our dataset, provide the appropriate write access, and retrieve any other data we need.

Only a few steps are necessary for implementing this authorization code flow. [Figure 9-1](https://learning.oreilly.com/library/view/the-complete-developer/9781098168810/xhtml/chapter9.xhtml#fig9-1) is a simplified description of these steps. Usually, developers use an SDK or a Node.js module to implement the steps and need to provide only a few properties, such as the client ID, client secret, and callback URL.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098168810/files/images/Figure9-1.jpg)

Figure 9-1: A simplified OAuth authorization grant flow

To register our app as an OAuth client, we need to provide GitHub with a _callback URL_ to our application, to which GitHub will redirect the user after the authorization request. This endpoint on our application receives the authorization grant. Recent OAuth implementations require the callback URL to use HTTPS as a way to protect the token from being intercepted.

Our app must use the resource owner’s credentials and the client credentials, an ID, and a secret to communicate with GitHub’s authorization server. The ID identifies the client, and the secret authenticates it. The app can then request the authorization to access specific resources, such as a weather station’s profile data. To do so, the weather station user needs to log in to GitHub’s authorization server. They’ll see a prompt that summarizes the requested access resources, such as read and write access to the profile or stream. If the user authorizes the requests with their user credentials, the OAuth client receives the authorization grant as a GET parameter in the callback URL, and the OAuth SDK we use in our application exchanges the authorization grant for an access token at the authorization server in the next step of the flow.

Here, the OAuth client uses the client credentials, which are the client ID and client secret, in combination with the previously received authorization grant to request an access token from the OAuth provider’s authorization server. It is part of the GitHub infrastructure, and to complete the authorization flow, the authorization server authenticates the identity and verifies that the grant is valid for this identity. Finally, the app receives the bearer token from here and stores it in the user session.

With the token and the user session received from the OAuth provider, our app can now act on the user’s behalf and access their protected resources, such as the profile data from the resource server. To act on their behalf, we add the bearer token to the Authorization header in the HTTP requests; the OAuth provider checks our granted permission and verifies our identity with this token. To access the user’s data, we simply extract it from the session data and use it in our application’s code.

For the weather application, we could use the second option to query location-specific weather data from our database. We’d need to read the location property from the user’s session data and use that value as the ZIP code supplied to our API endpoint. In addition, we can access other properties, such as the description and the name or profile picture, to display them on the weather application’s status page for each station.

### Creating a JWT Token

Most bearer tokens are JWTs, and while the authorization server automatically issues them, it’s good to know what kind of information you can find in them. This section will walk you through the process of creating an example OAuth JWT for the weather service app. The JWT is a string made up of three sections divided by periods (.): the header, the payload, and the signature. The first two sections are Base64-encoded JSON objects, whereas the signature is a checksum of the previous two.

#### The Header

The first string we create is the _header_, which defines basic metadata such as the token’s type and the signatures used for the signing algorithm. [Listing 9-1](https://learning.oreilly.com/library/view/the-complete-developer/9781098168810/xhtml/chapter9.xhtml#Lis9-1) shows the creation of a simple header in JavaScript with the most essential metadata.

```
const headerObject = {
    "typ": "JWT",
    "alg": "HS256"
}
```

Listing 9-1: The JWT header for the OAuth2 weather service

We set the type of the weather service’s token to JWT and specify that we use the HMAC-SHA-256 algorithm to calculate the signature later. Finally, we store the JSON object in a constant to use later.

#### The Payload

Next, we create the second string, the _payload_, which stores the token’s data. Each property of the payload is called a _claim_. In OAuth, the claims describe the user object and, usually, the session data. The JWT specification contains three types of claims: registered, public, and private.

##### Registered Claims

There are seven registered claims, each three letters long. While not necessary in general JWTs, the iss, sub, auth, and exp registered claims are required for OAuth JWTs.

The _issuer claim_, iss, contains a unique identifier for the entity that issued the JWT. A good value might be the application’s URL, as shown in [Listing 9-2](https://learning.oreilly.com/library/view/the-complete-developer/9781098168810/xhtml/chapter9.xhtml#Lis9-2).

```
{
    "iss": "https://www.usemodernfullstack.dev/
}
```

Listing 9-2: A registered issuer claim

The _subject claim_, sub, identifies the principal to which the JWT belongs. For an OAuth client authentication flow, the subject claim must be the client ID of the OAuth client, whereas for an OAuth authorization grant, the subject should identify the resource owner or should pseudonymously identify an anonymous user. We create a sample subject claim in [Listing 9-3](https://learning.oreilly.com/library/view/the-complete-developer/9781098168810/xhtml/chapter9.xhtml#Lis9-3).

```
{
    "sub": "THE_CLIENT_ID"
}
```

Listing 9-3: A registered subject claim

The _audience claim_, aud, identifies the token’s recipient. Its value could be the token endpoint URL on the authorization server or anything else that identifies the recipient, such as an application ID. See [Listing 9-4](https://learning.oreilly.com/library/view/the-complete-developer/9781098168810/xhtml/chapter9.xhtml#Lis9-4) for an example.

```
{
    "aud": "api://endpoint"
}
```

Listing 9-4: A registered audience claim

The _expiration claim_, exp, identifies the time window during which the token is valid. After that period, the authorization server will reject the token and you’ll need to request a new one. An expiration claim’s value is a number whose date is defined in “seconds since the Unix Epoch,” a common format for timestamps. It is calculated by counting the number of seconds that have elapsed since January 1, 1970. [Listing 9-5](https://learning.oreilly.com/library/view/the-complete-developer/9781098168810/xhtml/chapter9.xhtml#Lis9-5) shows an example.

```
{
    "exp":  1134156400
}
```

Listing 9-5: A registered expiration claim

The _issued at claim_, iat, is optional and identifies the time at which the authorization server issued the token. You can determine a token’s age from this claim, which is also defined in seconds since the Unix Epoch, as shown in [Listing 9-6](https://learning.oreilly.com/library/view/the-complete-developer/9781098168810/xhtml/chapter9.xhtml#Lis9-6).

```
{
    "iat": 1134156200
}
```

Listing 9-6: A registered issued at claim

The _not before claim_, nfb, is optional and identifies the time at which the authorization server should start accepting the token. The authorization server will reject every token with an nfb claim in the future. We define it as a number in seconds since the Unix Epoch, as you can see in [Listing 9-7](https://learning.oreilly.com/library/view/the-complete-developer/9781098168810/xhtml/chapter9.xhtml#Lis9-7).

```
{
    "nfb": 1134156100
}
```

Listing 9-7: A registered not before claim

The _JWT claim_, jti, is optional and sets a unique ID for the token (see [Listing 9-8](https://learning.oreilly.com/library/view/the-complete-developer/9781098168810/xhtml/chapter9.xhtml#Lis9-8)).

```
{
    "jti": "b5f8f86f-82ab-451e-b391-bf6a07041787"
}
```

Listing 9-8: A registered JWT claim

The authorization server might keep a list of recent tokens and their expiration dates to check whether the token is being reused in a _replay attack_, which occurs when an attacker tries to access data by reusing a previously issued token.

##### Public Claims

A token’s issuer can define public claims for the purpose of adding an application-specific public API. Unlike private claims, these are custom properties defined for public access. The issuer should register these claims in the JWT Claims registry or use collision-resistant names with custom namespaces—for example, a UUID or the application’s name. Also, as public claims are meant for public consumption, they should never include private or sensitive information.

A public claim for the OAuth JWT of our fictional weather service might include the ZIP code to directly provide each station’s location data. By making the ZIP code a public claim, we won’t need to parse the user object and extract the ZIP code manually. Also, as the location is publicly available information on social media profiles, it’s not sensitive.

##### Private Claims

Private claims are custom claims that are neither registered claims nor public claims. We can define them to our liking, and they can be specific to our application or use case. Even though they don’t need to be collision resistant, using a private namespace is recommended. Unlike public claims, private claims contain information specific to the application and are intended to be used only internally. Whereas the public claims store generic information such as the name, the private claims contain the application’s user ID and role. For example, we could define a private claim for the OAuth JWT of our fictional weather service to specify the type of service we are using.

Now that you understand the payload object’s possible properties, you can create a complete payload like the one in [Listing 9-9](https://learning.oreilly.com/library/view/the-complete-developer/9781098168810/xhtml/chapter9.xhtml#Lis9-9), which specifies GitHub as the service.

```
const payloadObject = {
    "exp": 234133423,
    "weather_public_zip": "96815",
    "weather_private_type": "GitHub"
}
```

Listing 9-9: The JWT payload for the OAuth weather service

Again, we create a constant and store the object there. Our payload has three claims, each of a different type. It’s up to the publisher of the JWT token to decide which claims to include; for this example, we limit the size of the token to one of each type. The registered claim exp sets the expiration date and time, zip is a public claim, and role is a private claim. Both use the custom namespace weather to minimize the risk of a collision.

#### The Signature

With the header and payload in place, we create a JWT signature by using the algorithm specified in the header to calculate the checksum. We pass the header and payload as Base64-encoded strings and a custom secret to the checksum function. As an exercise, we’ll create the signature in TypeScript with the code from [Listing 9-10](https://learning.oreilly.com/library/view/the-complete-developer/9781098168810/xhtml/chapter9.xhtml#Lis9-10). You’ll see that the secret is hardcoded for simplicity here. In production code, this secret should be stored in an environment variable.

Save the code as _index.ts_ in a TypeScript project, or use npx ts-node index.ts to run it locally. If you prefer, you can also use a TypeScript sandbox at [_https://codesandbox.io_](https://codesandbox.io/) or [_https://stackblitz.com_](https://stackblitz.com/) to run it. Generate a fresh secret (_[https://www.usemodernfullstack.dev/generate-secret](https://www.usemodernfullstack.dev/generate-secret)_) and use it instead of the one in the listing to see how the token changes.

```
import {createHmac} from "crypto";

const base64UrlEncode = (data: string): string => {
    return Buffer.from(data, "utf-8").toString("base64");
};

const headerObject = {
    typ: "JWT",
    alg: "HS256"
};

const payloadObject = {
    exp: 234133423,
    weather_public_zip: "96815",
    weather_private_type: "GitHub"
};

const createJWT = () => {
    const base64Header = base64UrlEncode(JSON.stringify(headerObject));
    const base64Payload = base64UrlEncode(JSON.stringify(payloadObject));

    const secret = "59c4b48eac7e9ac37c046ba88964870d";

    const signature: string = createHmac("sha256", secret)
        .update(`${base64Header}.${base64Payload}`)
        .digest("hex");

        return [base64Header, base64Payload, signature].join(".");
};

console.log(createJWT());
```

Listing 9-10: An index.ts file to calculate the JWT signature for the OAuth2 weather service

We use Node.js’s standard crypto module and then create a library for transforming the JSON objects into Base64-encoded strings via buffers. We pass the strings and the secret to the crypto module’s createHmac function to initialize the HMAC object with sha256 as the hashing algorithm, Then we feed the Base64-encoded header and payload string, separated by a period, to the HMAC object. Finally, we convert the result to a hexadecimal format.

To obtain the JWT string, we create an array containing the Base64-encoded strings from the header and payload objects, as well as the Base64-encoded signature. To convert the array into a string that uses a period to separate every part, we call Array.join with a period as a separator and return the resulting JWT.

To generate the JWT, we run the script. The final JWT token logged to the console should look similar to the one in [Listing 9-11](https://learning.oreilly.com/library/view/the-complete-developer/9781098168810/xhtml/chapter9.xhtml#Lis9-11).

```
eyJ0eXAiOiJKV1QiLCJhbGciOiJIUzI1NiJ9.eyJleHAiOjIzNDEzMzQyMywid2VhdGhlcl9wdWJsa
WNfemlwIjoiOTY4MTUiLCJ3ZWF0aGVyX3ByaXZhdGVfdHlwZSI6IkdpdEh1YiJ9.f667c81749886e
e01831376a38fbdba4d7f59a14c14f3a60e1bbee977c993ac9
```

Listing 9-11: The final JWT token for the OAuth2 weather service

In the next section, we’ll use our new knowledge to walk through an actual OAuth flow.

Exercise 9: Access a Protected Resource

Now that you understand OAuth’s components and the theory behind the authorization code flow, let’s work with a practical example. We’ll try to access the protected resource hosted by an OAuth server at _[https://www.usemodernfullstack.dev/protected/resource](https://www.usemodernfullstack.dev/protected/resource)_. Run the exercise’s cURL commands from your terminal to follow along.

First, attempt to access the protected resource without an access token by sending a GET request for it:

```
$ curl -i \
    -X GET 'https://www.usemodernfullstack.dev/protected/resource' \
    -H 'Accept: text/html'
--snip--
HTTP/2 401
Content-Type: text/html; charset=utf-8
--snip--
<h1>Unauthorized request: no authentication given</h1>
```

We use the -i flag to output the headers, and when we search the response for the HTTP code, we see a _401_ status code, which tells us that we’re not authorized to access the resource and must obtain an access token.

To get an access token, we’ll set up an OAuth client by creating a user account and registering it with the provider to receive a client ID and client secret. Then we’ll make a request to the _/oauth/authorize_ endpoint, log in with the user’s credentials, and receive the authorization grant on our callback URL. Next, we’ll exchange the grant code for an access token on the _/oauth/access_token_ endpoint. Finally, we’ll make the same request again, providing the access token in the header.

The callback URL can be any URL here, as we’re not sending any actual data to it. But for a real authorization grant flow, it needs to be an endpoint on your application. Usually, an OAuth SDK provides these, as it handles the response and tokens.

#### Setting Up the Client

Before we start the OAuth flow, we need to create a user and register an OAuth client. Open [_https://www.usemodernfullstack.dev/register_](https://www.usemodernfullstack.dev/register) in your browser. On the form shown in [Figure 9-2](https://learning.oreilly.com/library/view/the-complete-developer/9781098168810/xhtml/chapter9.xhtml#fig9-2), create a user account with a username and password of your choice.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098168810/files/images/Figure9-2.jpg)

Figure 9-2: Creating a user account with the OAuth provider

Then proceed to register a client by providing a callback URL ([Figure 9-3](https://learning.oreilly.com/library/view/the-complete-developer/9781098168810/xhtml/chapter9.xhtml#fig9-3)). This callback URL points to the OAuth callback endpoint on our application. Usually, the SDK or the OAuth provider supplies you with instructions on how to set this up.

![](https://learning.oreilly.com/api/v2/epubs/urn:orm:book:9781098168810/files/images/Figure9-3.jpg)

Figure 9-3: Registering a client application with the OAuth server to receive the client credentials

The form is prefilled with a callback URL similar to a typical OAuth callback structure. Usually, you find them in the SDK’s documentation. Don’t worry that the URL _http://localhost:3000/oauth/callback_ doesn’t exist on your application. For this exercise, we won’t send any actual data to it; instead, we’ll see that it’s part of the request and response flow when we go through the API calls. Click the button to move on to the next step, where you create the OAuth client. Make sure to write down your username, password, client ID, and client secret. You’ll need all of these for the next steps. Then click **Register Your OAuth Client** to complete the process.

#### Logging In to Receive the Authorization Grant

Now the user we registered must use their credentials to log in to the OAuth provider, allowing the client application to access their resources. We call the OAuth REST API endpoint _/oauth/authorize_ and (as the resource owner) log in with our user credentials, which is the first step of the flow. The API response returns a redirect to the callback URL, which contains the authorization grant in the URL parameter code.

In a real application, the resource owner would click some “Log in with OAuth” button and enter their credentials, and the API calls would happen behind the scenes. But for the purposes of this exercise, we’ll perform all API requests manually. By using the raw API calls, we’ll see the actions that SDKs usually abstract. Call the REST endpoint directly with the following cURL command:

```
$ curl -i \
    -X POST 'https://www.usemodernfullstack.dev/oauth/authenticate' \
    -H 'Accept: text/html' \
    -H 'Content-Type: application/x-www-form-urlencoded' \
    -d "response_type=code\
&client_id=<OAUTH_CLIENT_ID>\
&state=4nBjkh31\
&scope=read\
&redirect_uri=http://localhost:3000/oauth/callback\
&username=<OAUTH_USER>\
&password=<OAUTH_PASSWORD>"
--snip--
HTTP/2 302
Content-Type: text/html; charset=utf-8
location: http://localhost:3000/oauth/callback?code=<AUTHORIZATION_GRANT>&state=4nBjkh31
```

This POST request logs in to the OAuth provider. We set the URL to the _oauth/authenticate_ endpoint, as well as our Accept header and the appropriate Content-Type header, application/x-www-form-urlencoded, for form data.

We use the -d flag to send the POST data indicating that we’re looking for an authorization code. To split the POST data into readable chunks, we need to use double quotes (") to wrap it and the backslash (\) for line breaks. We add the client ID we received from the OAuth provider and the callback URL we discussed earlier. The scope parameter specifies the permissions we’re asking for, while the state parameter contains a unique random string that mitigates cross-site request forgery (CSRF) attacks. The OAuth provider should return this state parameter along with the authorization code so that we can verify that its value hasn’t changed, proving that the response originated from the correct API and not from a third party. In addition, we send the user credentials we registered before.

The response headers show us that everything worked as expected. The OAuth API responds with a status code of _302_ and redirects to the callback URL we provided. As you can see in the location header, the redirect to the callback URL contains the authorization grant in the code parameter, as well as the state parameter we sent. Unlike the state, which is just being reflected, the authorization grant is unique and depends on the request data.

#### Using the Authorization Grant to Get the Access Token

Next, we use the authorization grant to request an access token from the OAuth server. Copy the code you received in the preceding step and use it to request the bearer access token with the client credentials from the _/oauth/access_token_ API endpoint:

```
$ curl -i \
    -X POST 'https://www.usemodernfullstack.dev/oauth/access_token' \
    -H 'Accept: text/html, application/json' \
    -H 'Content-Type: application/x-www-form-urlencoded' \
    -d "code=<AUTHORIZATION_GRANT>\
&grant_type=authorization_code\
&redirect_uri=http://localhost:3000/oauth/callback\
&client_id=<OAUTH_CLIENT_ID>\
&client_secret=<OAUTH_CLIENT_SECRET>"
--snip--
HTTP/2 200 OK
Content-Type: application/json; charset=utf-8

{
    "access_token":"9bd55e2acf046128a54b76eada1ea6e0f909ca53",
    "token_type":"Bearer",
    "expires_in":3599,
    "refresh_token":"79a22d2b37c635a6095f5548ca08ea632deae573",
    "scope":"read"
}
```

This POST request to the OAuth server uses the Accept header to accept a JSON response and sets the Content-Type header to a value for POST form data. We send the form data itself with the data-raw flag. The data contains the authorization grant we received in the code parameter, a grant_type parameter that tells the API endpoint to expect an authorization grant flow, and the same redirect URL as before. We also pass in the client ID and secret.

The response has an HTTP status code of _200_, which means the request succeeded. In the response body, we received the access token and additional details. Copy the access token’s value for the next step.

#### Using the Access Token to Get the Protected Resource

We now have an access token from the OAuth server that we can use to retrieve the protected resource we couldn’t access at the beginning of this exercise. Use the same cURL command to request _[https://www.usemodernfullstack.dev/protected/resource](https://www.usemodernfullstack.dev/protected/resource)_, and replace the ACCESS_TOKEN placeholder with the access token:

```
$ curl -i \
    -X GET 'https://www.usemodernfullstack.dev/protected/resource' \
    -H 'Accept: text/html' \
    -H 'Authorization: Bearer <ACCESS_TOKEN>'
--snip--
HTTP/2 200 OK
Content-Type: text/html; charset=utf-8
--snip--
<h1>This page is secured.</h1>
--snip--
```

We use the Authorization header with the Bearer keyword and the access token we received from the authorization grant flow in the access_token property. When we search for the HTTP status code, we see that instead of a code of _401_, we receive a code of _200_. On closer inspection, we also see that the response’s body contains the secured content.

We manually walked through all the necessary steps for receiving a working access token. This exercise is appropriate for educational purposes only; as mentioned earlier in this chapter, we usually use an SDK or a library such as _next-auth_ to implement an OAuth flow.

### Summary

Authentication involves using credentials to authorize access, whereas authorization defines and grants access rights. This chapter covered implementing authorization with the OAuth2 protocol. You became familiar with the authorization grant flow, the most common OAuth flow used in full-stack web applications, and learned how to create JWTs. Then you practiced manually working with OAuth, getting and using the JWT bearer token, and applying the OAuth flow to your application from a bird’s-eye view.

You can find additional resources, tutorials, and specifications at [_https://oauth.net_](https://oauth.net/). The next chapter covers Docker, a containerization platform that decouples your development environment from your local machine.